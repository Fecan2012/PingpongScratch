
const GENERIC_OPCODE = {
    SINGLESTEPS: 0xc1,
    SCHEDULEDSTEPS: 0xca,
    SCHEDULEDPOINTS: 0xcb,
    CONTINUOUSSTEPS: 0xcc,
    AGGREGATESTEPS: 0xcd,
    LEDMATRIX: 0xa2,
    SERVO: 0xe1
}

const GENERIC_METHOD = {
    CONTINOUS: 0,
    RELATIVE_SINGLE: 1,
    ABSOLUTE_SINGLE: 2,
    SCHEDULED_STEPS: 3,
    SCHEDULED_POINTS: 4
}

const GENERIC_MODE = {
    MULTIROLE: 2,
    CRCCHECK: 3
}

const GENERIC_STEPTYPE = {
    FULL: 0,
    SERVO: 4
}

const GENERIC_PAUSESTATE = {
    PAUSE: 1,
    RESUME: 2
}

const PROPERTY = {
    PERI: 0x01,
    MULTI: 0x02,
    PORT: 0x80,
    ADDRESS: 0x70
}

const PROPERTY_MUSIC = {
    PLAY: 0x00,
    PAUSE: 0x01,
    RESUME: 0x02
}

const PROPERTY_SENSOR = {
    METHOD: 0x00,
    VALUE: 0x01,
    ADC: 2
}

class PingPongUtil {

    static printUint8ArrayToHex(arrData, cmd) {
        var nCount = arrData.byteLength;
        var stringoutput = "";

        for (var i = 0; i < nCount; i++) {
            stringoutput += (arrData[i] & 0xff).toString(16).slice(-2) + " ";
        }
        console.log(cmd + " : " + stringoutput + "/" + nCount);
    }

    static makeGenericHeader(inoutBinaryData, nCubeID, nCubeCount, nOpCode, nBinarySize,
        bMethod, bStepType, bPauseState) {
        var nSize = 13 + nBinarySize;
        var nPos = 0;

        // 0. first add virtual cube id [0:3]
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;

        if (nCubeID == -1) // means all
            inoutBinaryData[nPos++] = 0xff;
        else
            inoutBinaryData[nPos++] = nCubeID;

        // 1. add assigned id [4:5]
        inoutBinaryData[nPos++] = nCubeCount * 16;
        inoutBinaryData[nPos++] = 0;

        // 2. add opcode [6]
        inoutBinaryData[nPos++] = nOpCode;

        // 3. packet Size set [7:8]
        inoutBinaryData[nPos++] = nSize / 256;
        inoutBinaryData[nPos++] = nSize % 256;

        // 4. mode set [9]
        inoutBinaryData[nPos++] = GENERIC_MODE.MULTIROLE; // fixed multirole

        // 5. method set
        inoutBinaryData[nPos++] = bMethod;

        // 6. stepType set Fixed
        inoutBinaryData[nPos++] = bStepType;

        // 7. pause state
        inoutBinaryData[nPos++] = bPauseState;
    }

    static makeGenericHeaderCRC(inoutBinaryData, nCubeID, nCubeCount, nOpCode, nBinarySize,
        bMethod, bStepType, bPauseState) {
        var nSize = 13 + nBinarySize;
        var nPos = 0;

        // 0. first add virtual cube id
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;

        if (nCubeID == -1) // means all
            inoutBinaryData[nPos++] = 0xff;
        else
            inoutBinaryData[nPos++] = nCubeID;

        // 1. add assigned id
        inoutBinaryData[nPos++] = nCubeCount * 16;
        inoutBinaryData[nPos++] = 0;

        // 2. add opcode
        inoutBinaryData[nPos++] = nOpCode;

        // 3. packet Size set
        inoutBinaryData[nPos++] = nSize / 256;
        inoutBinaryData[nPos++] = nSize % 256;

        // 4. mode set
        inoutBinaryData[nPos++] = GENERIC_MODE.CRCCHECK; // fixed multirole

        // 5. method set
        inoutBinaryData[nPos++] = bMethod;

        // 6. stepType set Fixed
        inoutBinaryData[nPos++] = bStepType;

        // 7. pause state
        inoutBinaryData[nPos++] = bPauseState;
    }

    static makeSingleData(nCubeNum, nCubeCount, nSpeed, nDistance, salt) {
        var nSPS = 0;
        var bInverse = false;

        if (nSpeed > 100)
            nSpeed = 100;

        if (nSpeed < -100)
            nSpeed = -100;

        if (nSpeed < 0) {
            bInverse = true;
            nSpeed *= -1;
        }

        if (nSpeed == 0)
            nSPS = 0;
        else {
            nSPS = Math.abs(nSpeed) * 9 + 100;
            if (bInverse) {
                nSPS *= -1;
            }

            nSPS = Math.round(nSPS);
        }

        if (nDistance < 0)
            nDistance = 0;
        // unsigned to signed
        nStep = Math.round(nDistance * salt);

        if (nStep > 32768)
            nStep = 32768;

        var SingleData = new Uint8Array(19);

        PingPongUtil.makeGenericHeader(SingleData, nCubeNum, nCubeCount,
            GENERIC_OPCODE.SINGLESTEPS, 6,
            GENERIC_METHOD.RELATIVE_SINGLE,
            GENERIC_STEPTYPE.FULL,
            GENERIC_PAUSESTATE.PAUSE);
        // signed to unsigned
        if (nSPS < 0)
        {
            nSPS = 65536 + nSPS;

        }

        SingleData[13] = nSPS / 256;
        SingleData[14] = nSPS % 256;
        SingleData[15] = 0;
        SingleData[16] = 0;
        SingleData[17] = nStep / 256;
        SingleData[18] = nStep % 256;

        return SingleData;
    }

    // Make Task Header
    static makeTaskHeader(inoutBinaryData, nCubeID, nTaksID, nOpCode, npSize, property, pSize) {
        var nPos = 0;

        // 0. first add virtual cube id [0:3]
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;
        inoutBinaryData[nPos++] = 0xff;

        if (nCubeID == -1) // means all
            inoutBinaryData[nPos++] = 0xff;
        else
            inoutBinaryData[nPos++] = nCubeID-1;

        // 1. add task id [4:5]
        inoutBinaryData[nPos++] = 0x00;
        inoutBinaryData[nPos++] = nTaksID;

        // 2. add opcode [6]
        inoutBinaryData[nPos++] = nOpCode;

        // 3. packet Size set [7:8]
        inoutBinaryData[nPos++] = 0x00;
        inoutBinaryData[nPos++] = npSize;

        if(pSize == 1)
            // 4. case #1: property set [9]
            inoutBinaryData[nPos++] = property; 

        // 5. case #2: property set [9][10]
        inoutBinaryData[nPos++] = 0x00;
        inoutBinaryData[nPos++] = property; 
    }

    static makeMatrixPixelData(nTaskID, nCubeId,coordx, coordy, plot) {

        var MatrixData = new Uint8Array(13);

        PingPongUtil.makeTaskHeader(MatrixData, nCubeId, nTaskID, 0xa2, 0x0d, PROPERTY.ADDRESS, 1);

        MatrixData[10] = coordy;
        MatrixData[11] = coordx;
        MatrixData[12] = plot;

        return MatrixData;
    }

    static makeMatrixStringData(nTaskID, nCubeId, mString, mSecond) {
        if (mString.length > 20)
            return;
        var nPsize = 12 + mString.length;    
        if (mString == 0x00) {
            console.log("clear"); 
            nPsize = 12;
        }
        
        console.log("nPsize +  " + nPsize);

        var MatrixData = new Uint8Array(nPsize);

        PingPongUtil.makeTaskHeader(MatrixData, nCubeId, nTaskID, 0xa2, nPsize, PROPERTY.ADDRESS, 1);

        MatrixData[10] = Math.round((mSecond * 100) / (mString.length * 8));
        MatrixData[11] = 0x00;
        
        for(var i=12; i<MatrixData.length; i++)
        {
            MatrixData[i] = mString.charCodeAt(i - 12);
        }

        return MatrixData;
    }

    static makeMatrixClearData(nTaskID) {
        var nPsize = 11;

        var MatrixData = new Uint8Array(nPsize);

        PingPongUtil.makeTaskHeader(MatrixData, 0x00, nTaskID, 0xa2, nPsize, PROPERTY.ADDRESS, 1);

        MatrixData[10] = 0x02;
        
        return MatrixData;
    }
    // Set Servo Degree
    static makeServoDegreeData(nCubeId, sDegree) {
        var nPsize = 13;

        var ServoData = new Uint8Array(nPsize);

        PingPongUtil.makeTaskHeader(ServoData, nCubeId, 0X00, 0xe1, nPsize, PROPERTY.PERI, 1);

        ServoData[11] = sDegree;
        ServoData[12] = 0x00;  // Timeout

        return ServoData;
    }

    static makePlayNoteData(nCubeId, nNote, nDuration, pType) {
        var nPsize = 14;

        var MusicData = new Uint8Array(nPsize);

        PingPongUtil.makeTaskHeader(MusicData, nCubeId, 0xa1, 0xe8, nPsize, PROPERTY_MUSIC.PLAY, 2);
        MusicData[11] = nNote - 8;
        if(pType == 1){
            console.log("pType " + pType);
            MusicData[12] = nDuration;
            MusicData[13] = 0x00;
        } else if(pType == 2){
            MusicData[12] = 0x00;
            MusicData[13] = nDuration;
        }
        return MusicData;
    }
    /*
    static makeSensorData(nDelay) {
        var nPsize = 11;

        var SensorData = new Uint8Array(nPsize);
        
        PingPongUtil.makeTaskHeader(SensorData, 0x00, 0xc8, 0xb8, nPsize, PROPERTY_SENSOR.VALUE, 2);
        SensorData[9] = nDelay;

        return SensorData;
    }
    */
    static makeSingleDataWillCheckCRC(nCubeNum, nCubeCount, nSpeed, nDistance, salt) {
        var nSPS = 0;
        var bInverse = false;

        if (nSpeed > 100)
            nSpeed = 100;

        if (nSpeed < -100)
            nSpeed = -100;

        if (nSpeed < 0) {
            bInverse = true;
            nSpeed *= -1;
        }

        if (nSpeed == 0)
            nSPS = 0;
        else {
            nSPS = Math.abs(nSpeed) * 9 + 100;
            if (bInverse) {
                nSPS *= -1;
            }

            nSPS = Math.round(nSPS);
        }

        if (nDistance < 0)
            nDistance = 0;

        nStep = Math.round(nDistance * salt);

        if (nStep > 32768)
            nStep = 32768;

        var SingleData = new Uint8Array(19);

        PingPongUtil.makeGenericHeaderCRC(SingleData, nCubeNum, nCubeCount,
            GENERIC_OPCODE.SINGLESTEPS, 6,
            GENERIC_METHOD.RELATIVE_SINGLE,
            GENERIC_STEPTYPE.FULL,
            GENERIC_PAUSESTATE.PAUSE);

        if (nSPS < 0) {
            nSPS = 65536 + nSPS;

        }

        SingleData[13] = 0;
        SingleData[14] = 0;
        SingleData[15] = nSPS / 256;
        SingleData[16] = nSPS % 256;
        SingleData[17] = nStep / 256;
        SingleData[18] = nStep % 256;

        return SingleData;
    }

    static makeSingleDataByStep(nCubeNum, nCubeCount, nSPS, nStep) {
        var bInverse = false;

        if (nSPS > 0 && nSPS < 100)
            nSPS = 100;

        if (nSPS < 0 && nSPS > -100)
            nSPS = -100;

        if (nStep > 32768)
            nStep = 32768;

        var SingleData = new Uint8Array(19);

        PingPongUtil.makeGenericHeader(SingleData, nCubeNum, nCubeCount,
            GENERIC_OPCODE.SINGLESTEPS, 6,
            GENERIC_METHOD.RELATIVE_SINGLE,
            GENERIC_STEPTYPE.FULL,
            GENERIC_PAUSESTATE.PAUSE);

        if (nSPS < 0) {
            nSPS = 65536 + nSPS;
        }

        SingleData[13] = nSPS / 256;
        SingleData[14] = nSPS % 256;
        SingleData[15] = 0;
        SingleData[16] = 0;
        SingleData[17] = nStep / 256;
        SingleData[18] = nStep % 256;

        return SingleData;
    }

    static makeContinuousData(nCubeNum, nCubeCount, nSpeed) {
        var nSPS = 0;
        var bInverse = false;

        if (nSpeed > 100)
            nSpeed = 100;

        if (nSpeed < -100)
            nSpeed = -100;

        if (nSpeed < 0) {
            bInverse = true;
            nSpeed *= -1;
        }

        if (nSpeed == 0)
            nSPS = 0;
        else {
            nSPS = Math.abs(nSpeed) * 9 + 100;
            if (bInverse) {
                nSPS *= -1;
            }

            nSPS = Math.round(nSPS);
        }

        var ContinuousData = new Uint8Array(15);

        if (nSPS == 0)
           PingPongUtil.makeGenericHeader(ContinuousData, nCubeNum, nCubeCount,
            GENERIC_OPCODE.CONTINUOUSSTEPS, 2,
            GENERIC_METHOD.CONTINOUS,
            GENERIC_STEPTYPE.FULL,
                GENERIC_PAUSESTATE.PAUSE);
        else
            PingPongUtil.makeGenericHeader(ContinuousData, nCubeNum, nCubeCount,
                GENERIC_OPCODE.CONTINUOUSSTEPS, 2,
                GENERIC_METHOD.CONTINOUS,
                GENERIC_STEPTYPE.FULL,
                GENERIC_PAUSESTATE.RESUME);

        if (nSPS < 0) {
            nSPS = 65536 + nSPS;
        }

        ContinuousData[13] = nSPS / 256;
        ContinuousData[14] = nSPS % 256;;

        return ContinuousData;
    }
    
    static makeAggregateStepsDataMultiRole(binDatas, nCubeCount, bMethod) {
        var nSize = 13;

        nSize += binDatas.length * binDatas[0].length;
        var AggregatorData = new Uint8Array(nSize);

        PingPongUtil.makeGenericHeader(AggregatorData, -1, nCubeCount, GENERIC_OPCODE.AGGREGATESTEPS,
            binDatas[0].length * binDatas.length, bMethod, GENERIC_STEPTYPE.FULL, 0);

        AggregatorData[0] = 0xff;
        AggregatorData[1] = 0xff;
        AggregatorData[2] = 0xff;
        AggregatorData[3] = 0xaa;  // send to a red cube

        for (i = 0, nPos = 13; i < binDatas.length; i++) {
            for (j = 0; j < binDatas[i].length; j++) {
                AggregatorData[nPos + j] = binDatas[i][j];
            }

            nPos += binDatas[i].length;
        }

//        PingPongUtil.printUint8ArrayToHex(AggregatorData, "aggregatorData");
        return AggregatorData;
    }

    static makeAggregateSetMusicNotes(cArray, nArray, duration)
    {
        var nSize = 0x35;
        var AggregateMusicData = new Uint8Array(nSize);
        var noteArray = new Array(nArray.length);

        AggregateMusicData[0] = 0xff;
        AggregateMusicData[1] = 0xff;
        AggregateMusicData[2] = 0xff;
        AggregateMusicData[3] = 0xaa;  // send to a red cube
        AggregateMusicData[4] = 0x30;
        AggregateMusicData[5] = 0xa2;
        AggregateMusicData[6] = 0xe8;
        AggregateMusicData[7] = 0x00; 
        AggregateMusicData[8] = nSize; 
        AggregateMusicData[9] = 0x00;
        AggregateMusicData[10] = 0x00;

        for (var i = 0, nPos = 11; i < cArray.length; i++) {
            noteArray[i] = PingPongUtil.makePlayNoteData(cArray[i], nArray[i], duration, 1);
            for(var j = 0; j < noteArray[i].length; j++)
            {
                AggregateMusicData[nPos + j] = noteArray[i][j];
            }
            nPos += noteArray[i].length;
        }

        return AggregateMusicData;
    }

    static getResumeData() {
        var resumeData = new Uint8Array(10);

        resumeData[0] = 0xff;
        resumeData[1] = 0xff;
        resumeData[2] = 0xff;
        resumeData[3] = 0xff;
        resumeData[4] = 0x00;
        resumeData[5] = 0x00;
        resumeData[6] = 0xc0;
        resumeData[7] = 0x00;
        resumeData[8] = 0x0a;
        resumeData[9] = 0x02;

        return resumeData;
    }

    static getOrangeRedForSoundData() {
        var bData = new Uint8Array(14);

        bData[0] = 0xff;
        bData[1] = 0xff;
        bData[2] = 0x00;
        bData[3] = 0x07;
        bData[4] = 0x00;
        bData[5] = 0x00;
        bData[6] = 0xce;
        bData[7] = 0x00;
        bData[8] = 0x0e;
        bData[9] = 0x02;
        bData[10] = 0x00;
        bData[11] = 0x00;
        bData[12] = 0x07;
        bData[13] = 0x50;

        return bData;
    }

    static getDummyData() {
        var resumeData = new Uint8Array(10);

        resumeData[0] = 0xff;
        resumeData[1] = 0xff;
        resumeData[2] = 0xff;
        resumeData[3] = 0xff;
        resumeData[4] = 0x00;
        resumeData[5] = 0x00;
        resumeData[6] = 0x00;
        resumeData[7] = 0x00;
        resumeData[8] = 0x0a;
        resumeData[9] = 0x00;

        return resumeData;
    }

    static getPauseData() {
        var pauseData = new Uint8Array(10);

        pauseData[0] = 0xff;
        pauseData[1] = 0xff;
        pauseData[2] = 0xff;
        pauseData[3] = 0xff;
        pauseData[4] = 0x00;
        pauseData[5] = 0x00;
        pauseData[6] = 0xc0;
        pauseData[7] = 0x00;
        pauseData[8] = 0x0a;
        pauseData[9] = 0x01;

        return pauseData;
    }

    static getDisconnectData() {

        var DisconnectData = new Uint8Array(10);

        DisconnectData[0] = 0xff;
        DisconnectData[1] = 0xff;
        DisconnectData[2] = 0xff;
        DisconnectData[3] = 0xaa;
        DisconnectData[4] = 0x00;
        DisconnectData[5] = 0x00;
        DisconnectData[6] = 0xa8;
        DisconnectData[7] = 0x00;
        DisconnectData[8] = 0x0a;
        DisconnectData[9] = 0x01;

        return DisconnectData;
    }

    static getSensorsData(Position, Interval) {

        var SensorsData = new Uint8Array(11);

        SensorsData[0] = 0xff;
        SensorsData[1] = 0xff;
        SensorsData[2] = 0x00;
        SensorsData[3] = Position;
        SensorsData[4] = 0x00;
        SensorsData[5] = 0xc8;
        SensorsData[6] = 0xb8;
        SensorsData[7] = 0x00;
        SensorsData[8] = 0x0b;
        SensorsData[9] = Interval;
        SensorsData[10] = 0x1;

        return SensorsData;
    }

    static getDefaultPointDatas(start, end) {
        var txCharSend = new Uint8Array(20);

        txCharSend[0] = 0xff;
        txCharSend[1] = 0xff;
        txCharSend[2] = 0xff;
        txCharSend[3] = 0xff;

        txCharSend[4] = 0x0;
        txCharSend[5] = 0x0;

        txCharSend[6] = 0xcb;
        txCharSend[7] = 0x00;
        txCharSend[8] = 0x14;
        txCharSend[9] = 0x02;
        txCharSend[10] = 0x04;
        txCharSend[11] = 0x00;
        txCharSend[12] = 0x02;

        txCharSend[13] = 0x0;
        txCharSend[14] = 0x0;

        txCharSend[15] = 0x0;
        txCharSend[16] = start;
        txCharSend[17] = 0x0;
        txCharSend[18] = end;
        txCharSend[19] = 0x1;

        return txCharSend;
    }

    static getSoundData(nSound, nDuration) {
        var binSaved = new Uint8Array(13);

        binSaved[0] = 0xff;
        binSaved[1] = 0xff;
        binSaved[2] = 0xff;
        binSaved[3] = 0xff;
        binSaved[4] = 0x00;
        binSaved[5] = 0x00;
        binSaved[6] = 0xcf;
        binSaved[7] = 0x00;
        binSaved[8] = 0x0d;
        binSaved[9] = 0x0c;
        binSaved[10] = nSound;
        binSaved[11] = 0x01;
        binSaved[12] = nDuration;

        return binSaved;
    }

    static getSetVirtualColor(nCount) {
        var txCharSendTest = new Uint8Array(18);

        txCharSendTest[0] = 0xff;
        txCharSendTest[1] = 0xff;
        txCharSendTest[2] = 0xff;
        txCharSendTest[3] = 0xaa;
        txCharSendTest[4] = 0x00;
        txCharSendTest[5] = 0x00;
        txCharSendTest[6] = 0xae;
        txCharSendTest[7] = 0x00;
        txCharSendTest[8] = 0x12;
        txCharSendTest[9] = 0x00;
        txCharSendTest[10] = 0x0f;
        txCharSendTest[11] = 0x0f;
        txCharSendTest[12] = 0x0f;
        txCharSendTest[13] = 0x0f;
        txCharSendTest[14] = 0x0f;
        txCharSendTest[15] = 0x0f;
        txCharSendTest[16] = 0x0f;
        txCharSendTest[17] = 0x0f;

        for (var i = 0; i < nCount; i++)
        {
            txCharSendTest[10 + i] = i;
        }

        return txCharSendTest;
    }

    static getSetAggData(nCount) {
        var txCharSendTest = new Uint8Array(11);

        txCharSendTest[0] = 0xff;
        txCharSendTest[1] = 0xff;
        txCharSendTest[2] = 0xff;
        txCharSendTest[3] = 0xaa;
        txCharSendTest[4] = 0x00;
        txCharSendTest[5] = 0x00;
        txCharSendTest[6] = 0xaa;
        txCharSendTest[7] = 0x00;
        txCharSendTest[8] = 0x0b;
        txCharSendTest[9] = nCount;
        txCharSendTest[10] = 0x0a;

        return txCharSendTest;
    }

    static getSetMultiroleInAction(nCount) {
      var GroupPid = 0;
      try{
        if(document.getElementById('isGroup').value == "true"){
          GroupPid = document.getElementById('groupIdx').value;
        }
      }catch(e){}

        var txCharSendTest = new Uint8Array(11);

        //ff ff ff aa 20 00 ad 00 0b 0a 00

        txCharSendTest[0] = 0xff;
        txCharSendTest[1] = 0xff;
        txCharSendTest[2] = 0xff;
        txCharSendTest[3] = 0xaa;
        txCharSendTest[4] = nCount << 4;
        txCharSendTest[5] = 0x00;
        txCharSendTest[6] = 0xad;
        txCharSendTest[7] = 0x00;
        txCharSendTest[8] = 0x0b;
        txCharSendTest[9] = 0x0a;
        txCharSendTest[10] = 0x00;

        if(GroupPid != 0){
          txCharSendTest[9] = 0x1a;
          txCharSendTest[10] = GroupPid;
        }

        return txCharSendTest;
    }

    static pingpongsleep(milliseconds) {
        var start = new Date().getTime();
        for (var i = 0; i < 1e7; i++) {
            if ((new Date().getTime() - start) > milliseconds) {
                break;
            }
        }
    }

    static calculateTimeFromspeeddistance(nSpeed, nDistance, salt) {
        var nSPS = 0;

        if (nSpeed > 100)
            nSpeed = 100;

        if (nSpeed < -100)
            nSpeed = -100;

        if (nSpeed < 0) {
            bInverse = true;
            nSpeed *= -1;
        }

        if (nSpeed == 0)
            nSPS = 0;
        else {
            nSPS = Math.abs(nSpeed) * 9 + 100;
            nSPS = Math.round(nSPS);
        }

        if (nDistance < 0)
            nDistance = 0;

        nStep = Math.round(nDistance * salt);

        if (nStep > 32768)
            nStep = 32768;

        var value = Math.round((1100 - nSPS) / 99  * nStep);

        return value;
    }

    static calculateTimeFromSPSSTEPS(nSPS, nStep) {

        nSPS = Math.round(nSPS);

        if (nStep > 32768)
            nStep = 32768;

        var value = Math.round((1100 - nSPS) / 99 * nStep);

        return value;
    }

    static calculateTimeFromsScheduledData(strScheduledData, nStart, nEnd) {
        var strSplit = strScheduledData.split(",");
        var binData = new Uint8Array(strSplit.length);

        for (var i = 0; i < strSplit.length; i++) {
            binData[i] = parseInt(strSplit[i], 16);
        }


        return value;
    }

    static CalculateCRC16CCITTPX1021(bData, nStartPos, nEndMargin) {

        var bCRC16 = new Uint8Array(2);
        var crc = 0xFFFF;

        for (var i = nStartPos; i < bData.length - nEndMargin; i++)
        {
            crc = ((crc >> 8) | (crc << 8)) & 0xffff;
            crc ^= bData[i];
            crc ^= ((crc & 0xFF) >> 4) & 0xffff;
            crc ^= ((crc << 8) << 4) & 0xffff;
            crc ^= (((crc & 0xFF) << 4) << 1) & 0xffff;
        }

        bCRC16[0] = (crc >> 8) & 0xFF;
        bCRC16[1] = (crc & 0xFF);

        return bCRC16;
    }

    static getSignedIntfromByteData(bData) {
        var nData = parseInt("" + bData, 10);
        if (nData >= 128) {
            nData -= 256;
        }
        return nData;
    }
    static getUnsignedIntfromByteData(bData) {
        var nData = parseInt("" + bData, 10);

        return nData;
    }


    static getACCDataToDegreeMinus90To90fromByteData(bData) {
        var nData = PingPongUtil.getSignedIntfromByteData(bData);

        if (nData > 90)
            nData = 90;
        if (nData < -90)
            nData = -90;

        return nData;
    }
}

module.exports = PingPongUtil;
